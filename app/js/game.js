// Generated by CoffeeScript 1.10.0
var ballMaterial, ballTexture, balls, collisionGroupBalls, collisionGroupObstacles, collisionGroupPlayers, collisionGroupWalls, cursors, game, mapSettings, playerTexture, randomColor, ready, ship, socket, sounds, spawnBall, walls;

mapSettings = {
  outOfBoundsMargin: 100,
  halfPlayingWidth: 400,
  halfPlayingHeight: 250,
  halfNetHeight: 80,
  netDepth: 40,
  ballRadius: 12,
  playerRadius: 20,
  postRadius: 8,
  shootPower: 350,
  maxAccel: 300,
  shootingAccel: 200
};

collisionGroupPlayers = null;

collisionGroupBalls = null;

collisionGroupWalls = null;

collisionGroupObstacles = null;

cursors = null;

ship = null;

balls = null;

walls = null;

sounds = null;

ballTexture = null;

playerTexture = null;

ready = false;

ballMaterial = null;

socket = io();

game = new Phaser.Game(800, 600, Phaser.CANVAS, 'haxpark', {
  preload: function() {
    game.load.image('white', 'assets/sprites/white.png');
    game.load.image('mario', 'assets/sprites/mario.gif');
    game.load.image('ball', 'assets/sprites/white_outline.png', 32, 32);
    game.load.image('grass', 'assets/sprites/grass.jpg');
    game.load.audio('kick', 'assets/audio/wall.wav');
    return game.load.audio('wall', 'assets/audio/wall.wav');
  },
  createWalls: function() {
    var cen, cx, d, floorGroup, graphics, i, len, len1, n, ref, shape, sim, x, y;
    walls = new p2.Body({
      mass: 0,
      position: [0, 0]
    });
    sim = game.physics.p2;
    x = mapSettings.halfPlayingWidth;
    y = mapSettings.halfPlayingHeight;
    n = mapSettings.halfNetHeight;
    d = mapSettings.netDepth;
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * x)
    }), [0, sim.pxmi(y)], 0);
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * x)
    }), [0, sim.pxmi(-y)], 0);
    len = sim.pxmi(y - n);
    cen = y / 2.0 + n / 2.0;
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(x), sim.pxmi(cen)], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(x), sim.pxmi(-cen)], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(-x), sim.pxmi(cen)], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(-x), sim.pxmi(-cen)], Math.PI / 2.0);
    cx = sim.pxmi(x + n / 2.0);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [cx, sim.pxmi(n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [-cx, sim.pxmi(n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [cx, sim.pxmi(-n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [-cx, sim.pxmi(-n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * n)
    }), [sim.pxmi(x + d), 0], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * n)
    }), [sim.pxmi(-x - d), 0], Math.PI / 2.0);
    graphics = game.add.graphics(0, 0);
    graphics.lineStyle(6, 0xFFFFFF, 0.6);
    graphics.drawRect(-x, -y, x * 2, y * 2);
    graphics.drawRect(-x - d, -n, d, 2 * n);
    graphics.drawRect(x, -n, d, 2 * n);
    ref = walls.shapes;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      shape = ref[i];
      shape.collisionGroup = collisionGroupWalls.mask;
      shape.collisionMask = collisionGroupBalls.mask;
    }
    game.physics.p2.world.addBody(walls);
    floorGroup = game.add.group();
    floorGroup.z = 0.5;
    floorGroup.add(graphics);
  },
  create: function() {
    var ballBallCM, ballPlayerCM, ballPostCM, fieldBounds, halfWorldHeight, halfWorldWidth, i, j, len1, len2, margin, nx, ny, onFieldGroup, playerMaterial, post, postMaterial, px, py, ref, ref1, wallMaterial, xx, yy;
    margin = mapSettings.outOfBoundsMargin;
    px = mapSettings.halfPlayingWidth;
    py = mapSettings.halfPlayingHeight;
    nx = mapSettings.netDepth;
    ny = mapSettings.halfNetHeight;
    halfWorldWidth = px + margin + nx;
    halfWorldHeight = py + margin;
    game.world.setBounds(-halfWorldWidth, -halfWorldHeight, 2 * halfWorldWidth, 2 * halfWorldHeight);
    game.add.tileSprite(-halfWorldWidth, -halfWorldHeight, 2 * halfWorldWidth, 2 * halfWorldHeight, 'grass');
    game.physics.startSystem(Phaser.Physics.P2JS);
    game.physics.p2.setImpactEvents(true);
    game.physics.p2.restitution = 0.5;
    collisionGroupPlayers = game.physics.p2.createCollisionGroup();
    collisionGroupBalls = game.physics.p2.createCollisionGroup();
    collisionGroupWalls = game.physics.p2.createCollisionGroup();
    collisionGroupObstacles = game.physics.p2.createCollisionGroup();
    this.createWalls();
    balls = game.add.group();
    onFieldGroup = game.add.physicsGroup(Phaser.Physics.P2JS);
    onFieldGroup.z = 1;
    game.physics.p2.updateBoundsCollisionGroup();
    game.cameraPos = new Phaser.Point(0, 0);
    game.cameraLerp = 0.04;
    ballMaterial = game.physics.p2.createMaterial('ballMaterial');
    wallMaterial = game.physics.p2.createMaterial('wallMaterial');
    playerMaterial = game.physics.p2.createMaterial('playerMaterial');
    postMaterial = game.physics.p2.createMaterial('postMaterial');
    ballBallCM = game.physics.p2.createContactMaterial(ballMaterial, ballMaterial, {
      restitution: 0.8
    });
    ballPlayerCM = game.physics.p2.createContactMaterial(ballMaterial, playerMaterial, {
      restitution: 0.2,
      friction: 0
    });
    ballPostCM = game.physics.p2.createContactMaterial(ballMaterial, postMaterial, {
      restitution: 0.3
    });
    fieldBounds = new Phaser.Rectangle(-px, -py, 2 * px, 2 * py);
    playerTexture = game.add.bitmapData(37, 37);
    playerTexture.circle(18, 18, 17);
    playerTexture.draw('white', 4, 4);
    ballTexture = game.add.bitmapData(37, 37);
    ballTexture.circle(18, 18, 17);
    ballTexture.draw('ball', 2, 2);
    ref = [-1, 1];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      xx = ref[i];
      ref1 = [-1, 1];
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        yy = ref1[j];
        post = onFieldGroup.create(px * xx, ny * yy, ballTexture);
        post.scale.set(mapSettings.postRadius / 16.0);
        post.body.setCircle(mapSettings.postRadius);
        post.body["static"] = true;
        post.body.setMaterial(postMaterial);
        post.body.damping = 0.5;
        post.body.setCollisionGroup(collisionGroupObstacles);
        post.body.collides([collisionGroupPlayers, collisionGroupBalls]);
      }
    }
    sounds = {
      kick: game.add.audio('kick'),
      wall: game.add.audio('wall')
    };
    cursors = game.input.keyboard.addKeys({
      'up': Phaser.KeyCode.UP,
      'down': Phaser.KeyCode.DOWN,
      'left': Phaser.KeyCode.LEFT,
      'right': Phaser.KeyCode.RIGHT,
      'shoot': Phaser.KeyCode.X
    });
    return ready = true;
  },
  update: function() {}
});

randomColor = function() {
  var dice, val;
  val = Math.floor(Math.random() * 180) + 30;
  dice = Math.random() * 6;
  switch (false) {
    case !(dice < 1):
      return 0x0000FF + val * 0x000100;
    case !(dice < 2):
      return 0x0000FF + val * 0x010000;
    case !(dice < 3):
      return 0x00FF00 + val * 0x000001;
    case !(dice < 4):
      return 0x00FF00 + val * 0x010000;
    case !(dice < 5):
      return 0xFF0000 + val * 0x000001;
    case !(dice < 6):
      return 0xFF0000 + val * 0x000100;
  }
};

spawnBall = function(id, x, y) {
  var ball;
  ball = balls.create(x, y, ballTexture);
  ball.id = id;
  ball.anchor.x = 0.5;
  ball.anchor.y = 0.5;
  ball.tint = randomColor();
  return ball.scale.set(mapSettings.ballRadius / 16.0);
};

socket.on('positions', function(packet) {
  var ball, i, len1, matchedBall, ref;
  if (!ready) {
    return;
  }
  ref = packet.balls;
  for (i = 0, len1 = ref.length; i < len1; i++) {
    ball = ref[i];
    matchedBall = balls.children.find(function(b) {
      return b.id === ball.id;
    });
    if (!matchedBall) {
      spawnBall(ball.id, ball.x, ball.y);
    } else {
      matchedBall.x = ball.x;
      matchedBall.y = ball.y;
    }
  }
});

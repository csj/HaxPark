// Generated by CoffeeScript 1.10.0
var ballMaterial, ballTexture, balls, collisionGroupBalls, collisionGroupObstacles, collisionGroupPlayers, collisionGroupWalls, cursors, game, mapSettings, player, playerTexture, players, ready, socket, sounds, spawnBall, spawnPlayer, walls;

mapSettings = {
  outOfBoundsMargin: 100,
  halfPlayingWidth: 260,
  halfPlayingHeight: 200,
  halfNetHeight: 80,
  netDepth: 40,
  ballRadius: 12,
  playerRadius: 20,
  postRadius: 8,
  shootPower: 350,
  maxAccel: 300,
  shootingAccel: 200
};

collisionGroupPlayers = null;

collisionGroupBalls = null;

collisionGroupWalls = null;

collisionGroupObstacles = null;

cursors = null;

player = null;

balls = null;

players = null;

walls = null;

sounds = null;

ballTexture = null;

playerTexture = null;

ready = false;

ballMaterial = null;

socket = io();

game = new Phaser.Game(800, 600, Phaser.CANVAS, 'haxpark', {
  preload: function() {
    game.load.image('white', 'assets/sprites/white.png');
    game.load.image('mario', 'assets/sprites/mario.gif');
    game.load.image('ball', 'assets/sprites/white_outline.png', 32, 32);
    game.load.image('grass', 'assets/sprites/grass.jpg');
    game.load.audio('kick', 'assets/audio/wall.wav');
    return game.load.audio('wall', 'assets/audio/wall.wav');
  },
  createWalls: function() {
    var cen, cx, d, floorGroup, graphics, i, len, len1, n, ref, shape, sim, x, y;
    walls = new p2.Body({
      mass: 0,
      position: [0, 0]
    });
    sim = game.physics.p2;
    x = mapSettings.halfPlayingWidth;
    y = mapSettings.halfPlayingHeight;
    n = mapSettings.halfNetHeight;
    d = mapSettings.netDepth;
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * x)
    }), [0, sim.pxmi(y)], 0);
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * x)
    }), [0, sim.pxmi(-y)], 0);
    len = sim.pxmi(y - n);
    cen = y / 2.0 + n / 2.0;
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(x), sim.pxmi(cen)], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(x), sim.pxmi(-cen)], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(-x), sim.pxmi(cen)], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: len
    }), [sim.pxmi(-x), sim.pxmi(-cen)], Math.PI / 2.0);
    cx = sim.pxmi(x + n / 2.0);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [cx, sim.pxmi(n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [-cx, sim.pxmi(n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [cx, sim.pxmi(-n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(d)
    }), [-cx, sim.pxmi(-n)]);
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * n)
    }), [sim.pxmi(x + d), 0], Math.PI / 2.0);
    walls.addShape(new p2.Line({
      length: sim.pxmi(2 * n)
    }), [sim.pxmi(-x - d), 0], Math.PI / 2.0);
    graphics = game.add.graphics(0, 0);
    graphics.lineStyle(6, 0xFFFFFF, 0.6);
    graphics.drawRect(-x, -y, x * 2, y * 2);
    graphics.drawRect(-x - d, -n, d, 2 * n);
    graphics.drawRect(x, -n, d, 2 * n);
    ref = walls.shapes;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      shape = ref[i];
      shape.collisionGroup = collisionGroupWalls.mask;
      shape.collisionMask = collisionGroupBalls.mask;
    }
    game.physics.p2.world.addBody(walls);
    floorGroup = game.add.group();
    floorGroup.z = 0.5;
    floorGroup.add(graphics);
  },
  create: function() {
    var ballBallCM, ballPlayerCM, ballPostCM, fieldBounds, halfWorldHeight, halfWorldWidth, i, j, len1, len2, margin, nx, ny, onFieldGroup, playerMaterial, post, postMaterial, px, py, ref, ref1, wallMaterial, xx, yy;
    margin = mapSettings.outOfBoundsMargin;
    px = mapSettings.halfPlayingWidth;
    py = mapSettings.halfPlayingHeight;
    nx = mapSettings.netDepth;
    ny = mapSettings.halfNetHeight;
    halfWorldWidth = px + margin + nx;
    halfWorldHeight = py + margin;
    game.world.setBounds(-halfWorldWidth, -halfWorldHeight, 2 * halfWorldWidth, 2 * halfWorldHeight);
    game.add.tileSprite(-halfWorldWidth, -halfWorldHeight, 2 * halfWorldWidth, 2 * halfWorldHeight, 'grass');
    game.physics.startSystem(Phaser.Physics.P2JS);
    game.physics.p2.setImpactEvents(true);
    game.physics.p2.restitution = 0.5;
    collisionGroupPlayers = game.physics.p2.createCollisionGroup();
    collisionGroupBalls = game.physics.p2.createCollisionGroup();
    collisionGroupWalls = game.physics.p2.createCollisionGroup();
    collisionGroupObstacles = game.physics.p2.createCollisionGroup();
    this.createWalls();
    balls = game.add.group();
    players = game.add.group();
    onFieldGroup = game.add.physicsGroup(Phaser.Physics.P2JS);
    onFieldGroup.z = 1;
    game.physics.p2.updateBoundsCollisionGroup();
    game.cameraPos = new Phaser.Point(0, 0);
    game.cameraLerp = 0.04;
    ballMaterial = game.physics.p2.createMaterial('ballMaterial');
    wallMaterial = game.physics.p2.createMaterial('wallMaterial');
    playerMaterial = game.physics.p2.createMaterial('playerMaterial');
    postMaterial = game.physics.p2.createMaterial('postMaterial');
    ballBallCM = game.physics.p2.createContactMaterial(ballMaterial, ballMaterial, {
      restitution: 0.8
    });
    ballPlayerCM = game.physics.p2.createContactMaterial(ballMaterial, playerMaterial, {
      restitution: 0.2,
      friction: 0
    });
    ballPostCM = game.physics.p2.createContactMaterial(ballMaterial, postMaterial, {
      restitution: 0.3
    });
    fieldBounds = new Phaser.Rectangle(-px, -py, 2 * px, 2 * py);
    playerTexture = game.add.bitmapData(37, 37);
    playerTexture.circle(18, 18, 17);
    playerTexture.draw('white', 4, 4);
    ballTexture = game.add.bitmapData(37, 37);
    ballTexture.circle(18, 18, 17);
    ballTexture.draw('ball', 2, 2);
    ref = [-1, 1];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      xx = ref[i];
      ref1 = [-1, 1];
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        yy = ref1[j];
        post = onFieldGroup.create(px * xx, ny * yy, ballTexture);
        post.scale.set(mapSettings.postRadius / 16.0);
        post.body.setCircle(mapSettings.postRadius);
        post.body["static"] = true;
        post.body.setMaterial(postMaterial);
        post.body.damping = 0.5;
        post.body.setCollisionGroup(collisionGroupObstacles);
        post.body.collides([collisionGroupPlayers, collisionGroupBalls]);
      }
    }
    sounds = {
      kick: game.add.audio('kick'),
      wall: game.add.audio('wall')
    };
    cursors = game.input.keyboard.addKeys({
      'up': Phaser.KeyCode.UP,
      'down': Phaser.KeyCode.DOWN,
      'left': Phaser.KeyCode.LEFT,
      'right': Phaser.KeyCode.RIGHT,
      'shoot': Phaser.KeyCode.X
    });
    return ready = true;
  },
  update: function() {
    var i, len1, ref;
    ref = players.children;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      player = ref[i];
      if (player.shooting) {
        player.tint = 0xFFFFFF;
      } else {
        player.tint = player.originalTint;
      }
    }
  }
});

spawnBall = function(id, x, y, c) {
  var ball;
  ball = balls.create(x, y, ballTexture);
  ball.id = id;
  ball.anchor.x = 0.5;
  ball.anchor.y = 0.5;
  ball.tint = c;
  return ball.scale.set(mapSettings.ballRadius / 16.0);
};

spawnPlayer = function(id, x, y, c) {
  player = players.create(x, y, playerTexture);
  player.id = id;
  player.anchor.x = 0.5;
  player.anchor.y = 0.5;
  player.originalTint = c;
  player.tint = player.originalTint;
  player.inner_image = game.add.sprite(0, 0, 'mario');
  player.inner_image.anchor.setTo(0.5);
  player.inner_image.scale.set(1.3);
  player.addChild(player.inner_image);
  player.smoothed = true;
  player.scale.set(mapSettings.playerRadius / 16.0);
};

socket.on('positions', function(packet) {
  var ball, i, j, len1, len2, matchedBall, matchedPlayer, ref, ref1;
  if (!ready) {
    return;
  }
  ref = packet.balls;
  for (i = 0, len1 = ref.length; i < len1; i++) {
    ball = ref[i];
    matchedBall = balls.children.find(function(b) {
      return b.id === ball.id;
    });
    if (!matchedBall) {
      spawnBall(ball.id, ball.x, ball.y, ball.c);
    } else {
      matchedBall.x = ball.x;
      matchedBall.y = ball.y;
    }
  }
  ref1 = packet.players;
  for (j = 0, len2 = ref1.length; j < len2; j++) {
    player = ref1[j];
    matchedPlayer = players.children.find(function(p) {
      return p.id === player.id;
    });
    if (!matchedBall) {
      spawnPlayer(player.id, player.x, player.y, player.c);
    } else {
      matchedPlayer.x = player.x;
      matchedPlayer.y = player.y;
      matchedPlayer.shooting = player.shooting;
    }
  }
});

// Generated by CoffeeScript 1.10.0
var add, app, ball, ballMaterial, balls, cap, cen, collisionGroupBalls, collisionGroupObstacles, collisionGroupPlayers, collisionGroupWalls, collisionGroups, color, cx, d, divide, express, h, http, i, io, j, k, l, len, len1, len2, len3, len4, m, mapSettings, mult, n, normal, p2, player, playerMaterial, players, post, postMaterial, randX, randY, rando, randomColor, ref, ref1, ref2, ref3, server, shape, subtract, timeStep, w, wallMaterial, walls, world, x, xx, y, yy;

express = require('express');

app = express();

http = require('http');

server = http.createServer(app);

io = require('socket.io')(server);

p2 = require('p2');

randomColor = function(min, max) {
  var dice, val;
  val = Math.floor(Math.random() * (max - min)) + min;
  dice = Math.random() * 6;
  switch (false) {
    case !(dice < 1):
      return 0x0000FF + val * 0x000100;
    case !(dice < 2):
      return 0x0000FF + val * 0x010000;
    case !(dice < 3):
      return 0x00FF00 + val * 0x000001;
    case !(dice < 4):
      return 0x00FF00 + val * 0x010000;
    case !(dice < 5):
      return 0xFF0000 + val * 0x000001;
    case !(dice < 6):
      return 0xFF0000 + val * 0x000100;
  }
};

app.use(express["static"](__dirname + '/app'));

collisionGroupPlayers = null;

collisionGroupBalls = null;

collisionGroupWalls = null;

collisionGroupObstacles = null;

world = new p2.World({
  gravity: [0, 0]
});

mapSettings = {
  outOfBoundsMargin: 100,
  halfPlayingWidth: 260,
  halfPlayingHeight: 200,
  halfNetHeight: 80,
  netDepth: 40,
  ballRadius: 12,
  playerRadius: 20,
  postRadius: 8,
  shootPower: 350,
  maxAccel: 300,
  shootingAccel: 200
};

x = mapSettings.halfPlayingWidth;

y = mapSettings.halfPlayingHeight;

n = mapSettings.halfNetHeight;

d = mapSettings.netDepth;

w = x + d + mapSettings.outOfBoundsMargin;

h = y + mapSettings.outOfBoundsMargin;

ballMaterial = new p2.Material('ballMaterial');

wallMaterial = new p2.Material('wallMaterial');

playerMaterial = new p2.Material('playerMaterial');

postMaterial = new p2.Material('postMaterial');

walls = new p2.Body({
  mass: 0,
  position: [0, 0]
});

walls.addShape(new p2.Line({
  length: 2 * x
}), [0, y], 0);

walls.addShape(new p2.Line({
  length: 2 * x
}), [0, -y], 0);

len = y - n;

cen = y / 2.0 + n / 2.0;

walls.addShape(new p2.Line({
  length: len
}), [x, cen], Math.PI / 2.0);

walls.addShape(new p2.Line({
  length: len
}), [-x, cen], Math.PI / 2.0);

walls.addShape(new p2.Line({
  length: len
}), [x, -cen], Math.PI / 2.0);

walls.addShape(new p2.Line({
  length: len
}), [-x, -cen], Math.PI / 2.0);

cx = x + n / 2.0;

walls.addShape(new p2.Line({
  length: d
}), [cx, n]);

walls.addShape(new p2.Line({
  length: d
}), [-cx, n]);

walls.addShape(new p2.Line({
  length: d
}), [cx, -n]);

walls.addShape(new p2.Line({
  length: d
}), [-cx, -n]);

walls.addShape(new p2.Line({
  length: 2 * n
}), [x + d, 0], Math.PI / 2.0);

walls.addShape(new p2.Line({
  length: 2 * n
}), [-x - d, 0], Math.PI / 2.0);

collisionGroups = {
  players: 0x0001,
  balls: 0x0002,
  walls: 0x0004,
  obstacles: 0x0008
};

ref = walls.shapes;
for (i = 0, len1 = ref.length; i < len1; i++) {
  shape = ref[i];
  shape.material = wallMaterial;
  shape.collisionGroup = collisionGroups.walls;
  shape.collisionMask = collisionGroups.balls;
}

world.addBody(walls);

world.addContactMaterial(new p2.ContactMaterial(ballMaterial, ballMaterial, {
  restitution: 0.8
}));

world.addContactMaterial(new p2.ContactMaterial(ballMaterial, playerMaterial, {
  restitution: 0.2,
  friction: 0
}));

world.addContactMaterial(new p2.ContactMaterial(ballMaterial, postMaterial, {
  restitution: 0.3
}));

world.addContactMaterial(new p2.ContactMaterial(ballMaterial, wallMaterial, {
  restitution: 0.5
}));

randX = function() {
  return (Math.random() * 2 - 1.0) * x;
};

randY = function() {
  return (Math.random() * 2 - 1.0) * y;
};

balls = [];

players = [];

for (j = 1; j <= 30; j++) {
  ball = new p2.Body({
    position: [randX(), randY()],
    velocity: [(Math.random() * 2 - 1.0) * 500, (Math.random() * 2 - 1.0) * 500],
    mass: 0.3,
    damping: 0.5,
    fixedRotation: true
  });
  ball.addShape(new p2.Circle({
    radius: mapSettings.ballRadius,
    material: ballMaterial,
    collisionGroup: collisionGroups.balls,
    collisionMask: collisionGroups.balls | collisionGroups.walls | collisionGroups.players | collisionGroups.obstacles
  }));
  ball.color = randomColor(100, 255);
  balls.push(ball);
  world.addBody(ball);
}

ref1 = [0x0000FF, 0x00FF00, 0xFF0000, 0xFFFF00, 0xFF00FF, 0x00FFFF];
for (k = 0, len2 = ref1.length; k < len2; k++) {
  color = ref1[k];
  player = new p2.Body({
    position: [randX(), randY()],
    mass: 1,
    damping: 0.9,
    fixedRotation: true
  });
  player.addShape(new p2.Circle({
    radius: mapSettings.playerRadius,
    material: playerMaterial,
    collisionGroup: collisionGroups.players,
    collisionMask: collisionGroups.players | collisionGroups.balls | collisionGroups.obstacles
  }));
  player.color = color;
  player.coolDown = 0;
  players.push(player);
  world.addBody(player);
}

ref2 = [-1, 1];
for (l = 0, len3 = ref2.length; l < len3; l++) {
  xx = ref2[l];
  ref3 = [-1, 1];
  for (m = 0, len4 = ref3.length; m < len4; m++) {
    yy = ref3[m];
    post = new p2.Body({
      position: [x * xx, n * yy],
      mass: 0
    });
    post.addShape(new p2.Circle({
      radius: mapSettings.postRadius,
      material: postMaterial,
      collisionGroup: collisionGroups.obstacles,
      collisionMask: collisionGroups.balls | collisionGroups.players
    }));
    world.addBody(post);
  }
}

server.listen(8000);

console.log("Listening on 8000...");

io.on('connection', function(socket) {
  return console.log('a user connected');
});

timeStep = 1 / 30;

len = function(p) {
  return Math.sqrt(p[0] * p[0] + p[1] * p[1]);
};

normal = function(p) {
  d = len(p);
  return [p[0] / d, p[1] / d];
};

mult = function(p, scalar) {
  return [p[0] * scalar, p[1] * scalar];
};

divide = function(p, scalar) {
  return mult(p, 1 / scalar);
};

add = function(p1, p2) {
  return [p1[0] + p2[0], p1[1] + p2[1]];
};

subtract = function(p1, p2) {
  return add(p1, mult(p2, -1));
};

rando = function(a) {
  return (Math.random() * 2 - 1) * a;
};

cap = function(p, max) {
  d = len(p);
  if (d > max) {
    return mult(normal(p), max);
  } else {
    return p;
  }
};

setInterval(function() {
  var accel, closestBall, closestDist, direction, len5, len6, len7, o, packet, q, r, s, theDiff, theDist;
  for (q = 0, len5 = players.length; q < len5; q++) {
    player = players[q];
    closestBall = null;
    closestDist = 10000000;
    for (r = 0, len6 = balls.length; r < len6; r++) {
      ball = balls[r];
      theDiff = subtract(ball.position, player.position);
      theDist = len(theDiff);
      if (theDist - mapSettings.ballRadius - mapSettings.playerRadius < 5 && player.coolDown < new Date().getTime()) {
        player.coolDown = new Date().getTime() + 100;
        ball.velocity = add(ball.velocity, mult(normal(theDiff), mapSettings.shootPower));
      }
      if (theDist < closestDist) {
        closestBall = ball;
        closestDist = theDist;
      }
    }
    accel = mapSettings.maxAccel;
    direction = add(subtract(closestBall.position, player.position), [rando(30), rando(30)]);
    player.velocity = add(player.velocity, mult(normal(direction), accel * timeStep));
  }
  for (s = 0, len7 = balls.length; s < len7; s++) {
    ball = balls[s];
    ball.velocity = cap(ball.velocity, mapSettings.ballRadius / timeStep - 10);
  }
  world.step(timeStep);
  packet = {
    balls: (function() {
      var len8, results, t;
      results = [];
      for (t = 0, len8 = balls.length; t < len8; t++) {
        o = balls[t];
        results.push({
          id: o.id,
          x: o.position[0],
          y: o.position[1],
          c: o.color
        });
      }
      return results;
    })(),
    players: (function() {
      var len8, results, t;
      results = [];
      for (t = 0, len8 = players.length; t < len8; t++) {
        o = players[t];
        results.push({
          id: o.id,
          x: o.position[0],
          y: o.position[1],
          c: o.color
        });
      }
      return results;
    })()
  };
  return io.emit('positions', packet);
}, 1000 * timeStep);
